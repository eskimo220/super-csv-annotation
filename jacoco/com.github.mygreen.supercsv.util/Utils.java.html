<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="ja"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Utils.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Super CSV Annotation</a> &gt; <a href="index.source.html" class="el_package">com.github.mygreen.supercsv.util</a> &gt; <span class="el_source">Utils.java</span></div><h1>Utils.java</h1><pre class="source lang-java linenums">package com.github.mygreen.supercsv.util;

import java.lang.annotation.Annotation;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Objects;
import java.util.Optional;

import com.github.mygreen.supercsv.annotation.PatternFlag;
import com.github.mygreen.supercsv.builder.BuildCase;


/**
 * ユーティリティクラス。
 * 
 * @version 2.0
 * @author T.TSUCHIE
 *
 */
<span class="nc" id="L24">public class Utils {</span>
    
    /**
     * &lt;a href=&quot;http://www.joda.org/joda-time/&quot; target=&quot;_blank&quot;&gt;Joda-Time&lt;/a&gt;のライブラリが利用可能かどうか。
     */
    public static final boolean ENABLED_LIB_JODA_TIME;
    static {
        boolean enabled;
        try {
<span class="fc" id="L33">            Class.forName(&quot;org.joda.time.LocalDateTime&quot;);</span>
<span class="fc" id="L34">            enabled = true;</span>
<span class="nc" id="L35">        } catch(ClassNotFoundException e) {</span>
<span class="nc" id="L36">            enabled = false;</span>
<span class="fc" id="L37">        }</span>
<span class="fc" id="L38">        ENABLED_LIB_JODA_TIME = enabled;</span>
<span class="fc" id="L39">    }</span>
    
    /**
     * 文字列が空文字か判定する。
     * @param str
     * @return
     */
    public static boolean isEmpty(final String str) {
<span class="fc bfc" id="L47" title="All 4 branches covered.">        if(str == null || str.isEmpty()) {</span>
<span class="fc" id="L48">            return true;</span>
        }
        
<span class="fc bfc" id="L51" title="All 2 branches covered.">        if(str.length() == 1) {</span>
<span class="pc bpc" id="L52" title="1 of 2 branches missed.">            return str.charAt(0) == '\u0000';</span>
        }
        
<span class="fc" id="L55">        return false;</span>
    }
    
    /**
     * 文字列が空文字でないか判定する。
     * @param str
     * @return
     */
    public static boolean isNotEmpty(final String str) {
<span class="fc bfc" id="L64" title="All 2 branches covered.">        return !isEmpty(str);</span>
    }
    
    /**
     * コレクションが空か判定する。
     * @param collection
     * @return nullまたはサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L73" title="All 4 branches missed.">        if(collection == null || collection.isEmpty()) {</span>
<span class="nc" id="L74">            return true;</span>
        }
        
<span class="nc" id="L77">        return false;</span>
    }
    
    public static boolean isNotEmpty(final Collection&lt;?&gt; collection) {
<span class="nc bnc" id="L81" title="All 2 branches missed.">        return !isEmpty(collection);</span>
    }
    
    /**
     * 配列がが空か判定する。 
     * @param arrays
     * @return nullまたは、配列のサイズが0のときにtrueを返す。
     */
    public static boolean isEmpty(final Object[] arrays) {
<span class="pc bpc" id="L90" title="1 of 4 branches missed.">        if(arrays == null || arrays.length == 0) {</span>
<span class="fc" id="L91">            return true;</span>
        }
        
<span class="fc" id="L94">        return false;</span>
    }
    
    /**
     * 配列が空でないか判定する
     * @param arrays
     * @return
     */
    public static boolean isNotEmpty(final Object[] arrays) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        return !isEmpty(arrays);</span>
    }
    
    /**
     * 文字列形式のロケールをオブジェクトに変換する。
     * &lt;p&gt;アンダーバーで区切った'ja_JP'を分解して、Localeに渡す。
     * @since 1.2
     * @param str
     * @return 引数が空の時はデフォルトロケールを返す。
     */
    public static Locale getLocale(final String str) {
        
<span class="fc bfc" id="L115" title="All 2 branches covered.">        if(isEmpty(str)) {</span>
<span class="fc" id="L116">            return Locale.getDefault();</span>
        }
        
<span class="pc bpc" id="L119" title="1 of 2 branches missed.">        if(!str.contains(&quot;_&quot;)) {</span>
<span class="nc" id="L120">            return new Locale(str);</span>
        }
        
<span class="fc" id="L123">        final String[] split = str.split(&quot;_&quot;);</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if(split.length == 2) {</span>
<span class="fc" id="L125">            return new Locale(split[0], split[1]);</span>
            
        } else {
<span class="fc" id="L128">            return new Locale(split[0], split[1], split[2]);</span>
        }
        
    }
    
    /**
     * アノテーションの指定した属性値を取得する。
     * &lt;p&gt;アノテーションの修飾子はpublicである必要があります。&lt;/p&gt;
     * @param anno アノテーションのインスタンス
     * @param attrName 属性名
     * @param attrType 属性のタイプ。
     * @return 属性を持たない場合、空を返す。
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static &lt;T&gt; Optional&lt;T&gt; getAnnotationAttribute(final Annotation anno, final String attrName, final Class&lt;T&gt; attrType) {
        
        try {
<span class="fc" id="L145">            final Method method = anno.annotationType().getMethod(attrName);</span>
<span class="fc" id="L146">            method.setAccessible(true);</span>
<span class="pc bpc" id="L147" title="1 of 2 branches missed.">            if(!attrType.equals(method.getReturnType())) {</span>
<span class="nc" id="L148">                return Optional.empty();</span>
            }
            
<span class="fc" id="L151">            final Object value = method.invoke(anno);</span>
<span class="fc" id="L152">            return Optional.of((T)value);</span>
            
<span class="fc" id="L154">        } catch (Exception e) {</span>
<span class="fc" id="L155">            return Optional.empty();</span>
        }
        
    }
    
    /**
     * アノテーションの指定した属性値を持つかどうか判定する。
     * &lt;p&gt;アノテーションの修飾子はpublicである必要があります。&lt;/p&gt;
     * @param anno アノテーションのインスタンス
     * @param attrName 属性名
     * @param attrType 属性のタイプ。
     * @return 属性を持つ場合trueを返す。
     */
    public static &lt;T&gt;  boolean hasAnnotationAttribute(final Annotation anno, final String attrName, final Class&lt;T&gt; attrType) {
        
<span class="fc" id="L170">        return getAnnotationAttribute(anno, attrName, attrType).isPresent();</span>
        
    }
    
    /**
     * アノテーションの属性「cases」を持つ場合、指定した種類を持つか判定する。
     * &lt;p&gt;属性「buildCase」を持たない場合、または、空の配列の場合は、必ずtrueを返します。&lt;/p&gt;
     * 
     * @param anno 判定対象のアノテーション。
     * @param buildCase 組み立てる種類。
     * @return trueの場合、指定した種類を含みます。
     * @throws NullPointerException anno or buildCase is null.
     */
    public static boolean containsBuildCase(final Annotation anno, final BuildCase buildCase) {
        
<span class="fc" id="L185">        Objects.requireNonNull(anno);</span>
<span class="fc" id="L186">        Objects.requireNonNull(buildCase);</span>
        
<span class="fc" id="L188">        final Optional&lt;BuildCase[]&gt; attrCases = getAnnotationAttribute(anno, &quot;cases&quot;, BuildCase[].class);</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if(attrCases.isPresent()) {</span>
<span class="fc" id="L190">            final BuildCase[] casesValue = attrCases.get();</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">            if(casesValue.length == 0) {</span>
                // 値が空の配列の場合
<span class="fc" id="L193">                return true;</span>
            }
            
<span class="fc bfc" id="L196" title="All 2 branches covered.">            for(BuildCase value : casesValue) {</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">                if(value == buildCase) {</span>
<span class="fc" id="L198">                    return true;</span>
                }
            }
            
<span class="fc" id="L202">            return false;</span>
        }
        
        // 属性を持たない場合
<span class="fc" id="L206">        return true;</span>
    }
    
    /**
     * &lt;a href=&quot;http://www.joda.org/joda-time/&quot; target=&quot;_blank&quot;&gt;Joda-Time&lt;/a&gt;のライブラリが利用可能かどうか。
     * @return {@literal true}利用可能。
     */
    public static boolean isEnabledJodaTime() {
<span class="fc" id="L214">        return ENABLED_LIB_JODA_TIME;</span>
    }
    
    /**
     * プリミティブ型の初期値を取得する。
     * @param type プリミティブ型のクラス型。
     * @return 非プリミティブ型や該当するクラスがない場合はnullを返す。
     * @throws NullPointerException type is null.
     */
    public static Object getPrimitiveDefaultValue(final Class&lt;?&gt; type) {
        
<span class="fc" id="L225">        Objects.requireNonNull(type, &quot;type should not be null.&quot;);</span>
        
<span class="fc bfc" id="L227" title="All 2 branches covered.">        if(!type.isPrimitive()) {</span>
<span class="fc" id="L228">            return null;</span>
            
<span class="fc bfc" id="L230" title="All 2 branches covered.">        } else if(boolean.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L231">            return false;</span>
            
<span class="fc bfc" id="L233" title="All 2 branches covered.">        } else if(char.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L234">            return '\u0000';</span>
            
<span class="fc bfc" id="L236" title="All 2 branches covered.">        } else if(byte.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L237">            return (byte)0;</span>
            
<span class="fc bfc" id="L239" title="All 2 branches covered.">        } else if(short.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L240">            return (short)0;</span>
            
<span class="fc bfc" id="L242" title="All 2 branches covered.">        } else if(int.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L243">            return 0;</span>
            
<span class="fc bfc" id="L245" title="All 2 branches covered.">        } else if(long.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L246">            return 0l;</span>
            
<span class="fc bfc" id="L248" title="All 2 branches covered.">        } else if(float.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L249">            return 0.0f;</span>
            
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">        } else if(double.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L252">            return 0.0d;</span>
        }
        
<span class="nc" id="L255">        return null;</span>
        
    }
    
    /**
     * 文字列配列の結合
     * @param array1
     * @param array2
     * @return
     */
    public static String[] concat(final String[] array1, final String[] array2) {
        
<span class="fc" id="L267">        int size = array1.length + array2.length;</span>
<span class="fc" id="L268">        List&lt;String&gt; list = new ArrayList&lt;&gt;(size);</span>
<span class="fc" id="L269">        list.addAll(Arrays.asList(array1));</span>
<span class="fc" id="L270">        list.addAll(Arrays.asList(array2));</span>
        
<span class="fc" id="L272">        return list.toArray(new String[size]);</span>
        
    }
    
    /**
     * コレクションを配列に変換する。
     * @param collection 変換対象のコレクション。
     * @return 変換した配列。
     * @throws NullPointerException collection is null.
     */
    public static int[] toArray(final Collection&lt;Integer&gt; collection) {
<span class="fc" id="L283">        Objects.requireNonNull(collection);</span>
        
<span class="fc" id="L285">        final int size = collection.size();</span>
<span class="fc" id="L286">        final int[] array = new int[size];</span>
        
<span class="fc" id="L288">        int i=0;</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">        for(Integer value : collection) {</span>
<span class="fc" id="L290">            array[i] = value;</span>
<span class="fc" id="L291">            i++;</span>
<span class="fc" id="L292">        }</span>
        
<span class="fc" id="L294">        return array;</span>
    }
    
    /**
     * 正規表現のフラグを組み立てる。
     * @param flags 正規表現の列挙型のフラグ
     * @return
     */
    public static int buildRegexFlags(final PatternFlag[] flags) {
        
<span class="fc" id="L304">        int intFlag = 0;</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">        for(PatternFlag flag : flags) {</span>
<span class="fc" id="L306">            intFlag = intFlag | flag.getValue();</span>
        }
        
<span class="fc" id="L309">        return intFlag;</span>
        
    }
    
    /**
     * 先頭の文字を小文字にする。
     * @param str
     * @return 引数がnull、空文字の場合、そのまま返す。
     */
    public static String uncapitalize(final String str) {
        final int strLen;
<span class="nc bnc" id="L320" title="All 4 branches missed.">        if(str == null || (strLen = str.length()) == 0) {</span>
<span class="nc" id="L321">            return str;</span>
        }
        
<span class="nc" id="L324">        return new StringBuilder(strLen)</span>
<span class="nc" id="L325">            .append(String.valueOf(str.charAt(0)).toLowerCase())</span>
<span class="nc" id="L326">            .append(str.substring(1))</span>
<span class="nc" id="L327">            .toString();</span>
    }
    
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>